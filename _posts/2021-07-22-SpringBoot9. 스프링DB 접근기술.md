---

title: "9.SpringBoot 스프링DB 접근기술"
excerpt: "H2 데이터베이스 설치, 순수 jdbc"

categories: [devlog]

tag: javaSpring

toc: true

toc_sticky: true

date: 2021-07-22

last_modified_at: 2021-07-22
---





# 스프링DB 접근기술



#### H2 데이터베이스 설치

[H2데이터베이스설치](h2database.com)

해당사이트에서 다운로드



<img src="https://github.com/cano721/cano721.github.io/blob/master/_posts/md-images/springDB/springDB.JPG?raw=true">

* 설치 후 실행



<img src="https://github.com/cano721/cano721.github.io/blob/master/_posts/md-images/springDB/springDB2.JPG?raw=true">

* 실행 시 웹사이트에 해당화면 발생
* 연결버튼 클릭
* `JDBC URL`을 jdbc:h2:tcp://localhost/~/test로 수정 
  * 소켓을 통해 접근하는 방식
* 재연결



<img src="https://github.com/cano721/cano721.github.io/blob/master/_posts/md-images/springDB/springDB3.JPG?raw=true">

* 해당 화면에서 쿼리문 작성
  * drop table if exists member CASCADE;
    create table member
    (
     id bigint generated by default as identity,
     name varchar(255),
     primary key(id)
    );
    * spring에서 설정한 id Type Long은 여기선 bigint
    * generated by default as identity은 값을 셋팅하지않고 insert하면 db가 자동으로 채워줌
    * name과 pk도 설정
  * insert into member(name) values('spring1')
    * 맴버삽입 쿼리문
  * SELECT * FROM MEMBER 
    * 조회 쿼리문



#### 순수 jdbc



가장 오래된 방식. 현재는 사용하지 않음.



* 환경설정

  * build.gralde 파일에 jdbc,h2 데이터베이스 관련 라이브러리 추가

    * ```
      //  jdbc관련 라이브러리
         implementation 'org.springframework.boot:spring-boot-starter-jdbc'
         runtimeOnly 'com.h2database:h2'
      ```

  * resources - application.properties 에 셋팅

    * ```
      spring.datasource.url=jdbc:h2:tcp://localhost/~/test
      spring.datasource.driver-class-name=org.h2.Driver
      spring.datasource.username=sa
      ```

    * 스프링부트 2.4 이상 버전에는 `spring.datasource.username=sa` 을 꼭 추가해야함!

    * 추가하지않으면 Wrong user name or password 오류 발생

* repositoy 생성 -JdbcMemberRepository

  * ```
    package hello.hellospring.repository;
    import hello.hellospring.domain.Member;
    import org.springframework.jdbc.datasource.DataSourceUtils;
    import javax.sql.DataSource;
    import java.sql.*;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;
    public class JdbcMemberRepository implements MemberRepository {
        private final DataSource dataSource;
        
        public JdbcMemberRepository(DataSource dataSource) {
            this.dataSource = dataSource;
        }
        @Override
        public Member save(Member member) {
            String sql = "insert into member(name) values(?)";
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
            try {
                conn = getConnection();
                pstmt = conn.prepareStatement(sql,
                        Statement.RETURN_GENERATED_KEYS);
                pstmt.setString(1, member.getName());
                pstmt.executeUpdate();
                rs = pstmt.getGeneratedKeys();
                if (rs.next()) {
                    member.setId(rs.getLong(1));
                } else {
                    throw new SQLException("id 조회 실패");
                }
                return member;
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            }
        }
        @Override
        public Optional<Member> findById(Long id) {
            String sql = "select * from member where id = ?";
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
            try {
                conn = getConnection();
                pstmt = conn.prepareStatement(sql);
                pstmt.setLong(1, id);
                rs = pstmt.executeQuery();
                if(rs.next()) {
                    Member member = new Member();
                    member.setId(rs.getLong("id"));
                    member.setName(rs.getString("name"));
                    return Optional.of(member);
                } else {
                    return Optional.empty();
                }
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            }
        }
        @Override
        public List<Member> findAll() {
            String sql = "select * from member";
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
            try {
                conn = getConnection();
                pstmt = conn.prepareStatement(sql);
                rs = pstmt.executeQuery();
                List<Member> members = new ArrayList<>();
                while(rs.next()) {
                    Member member = new Member();
                    member.setId(rs.getLong("id"));
                    member.setName(rs.getString("name"));
                    members.add(member);
                }
                return members;
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            }
        }
        @Override
        public Optional<Member> findByName(String name) {
            String sql = "select * from member where name = ?";
            Connection conn = null;
            PreparedStatement pstmt = null;
            ResultSet rs = null;
            try {
                conn = getConnection();
                pstmt = conn.prepareStatement(sql);
                pstmt.setString(1, name);
                rs = pstmt.executeQuery();
                if(rs.next()) {
                    Member member = new Member();
                    member.setId(rs.getLong("id"));
                    member.setName(rs.getString("name"));
                    return Optional.of(member);
                }
                return Optional.empty();
            } catch (Exception e) {
                throw new IllegalStateException(e);
            } finally {
                close(conn, pstmt, rs);
            }
        }
        private Connection getConnection() {
            return DataSourceUtils.getConnection(dataSource);
        }
        private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
        {
            try {
                if (rs != null) {
                    rs.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                if (conn != null) {
                    close(conn);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        private void close(Connection conn) throws SQLException {
            DataSourceUtils.releaseConnection(conn, dataSource);
        }
    }
    ```



* SpringConfig 설정 변경

  * ```
    package hello.hellospring;
    
    import hello.hellospring.repository.JdbcMemberRepository;
    import hello.hellospring.repository.MemberRepository;
    import hello.hellospring.repository.MemoryMemberRepository;
    import hello.hellospring.service.MemberService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    import javax.sql.DataSource;
    
    @Configuration
    public class SpringConfig {
        
        private DataSource dataSource;
        
        @Autowired
        public SpringConfig(DataSource dataSource){
            this.dataSource = dataSource;
        }
        
        @Bean
        public MemberService memberService(){
            return new MemberService(memberRepository());
        }
    
        @Bean
        public MemberRepository memberRepository(){
    //        return new MemoryMemberRepository();
            return new JdbcMemberRepository(dataSource);
        }
    }
    ```



* DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체다. 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어준다. 그래서 DI를 받을 수 있다.



<img src="https://github.com/cano721/cano721.github.io/blob/master/_posts/md-images/springDB/springDB4.JPG?raw=true">







### 참조

[김영한님의 인프런강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8)
